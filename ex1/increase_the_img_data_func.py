import numpy as np
from PIL import Image
from os import listdir, makedirs, getcwd, path, rename
from time import sleep
from matplotlib import pyplot as plt
from copy import copy
from random import randrange
from shutil import rmtree
from define_parameters import *


class ImageClass(object):
    def __init__(self, noise_size_per_img_line=2, folders_name_dict=None):
        if folders_name_dict is None:
            folders_name_dict = {"Aleph": 'Aleph', "Alefa": 'Aleph', "Bet": 'Bet', "Gimmel": 'Gimmel',
                                 'Gimel': "Gimmel", "Dalet": 'Dalet', "He": 'He', "Vav": 'Vav',
                                 "Kaf": 'Kaf', "Lamed": 'Lamed'}
        self.__images_folder = INPUT_IMAGE_FOLDER
        self.__output_image_folder = OUTPUT_IMAGE_FOLDER
        self.__binary_output_folder = OUTPUT_FOLDER
        self.__source_binary_file_folder = SOURCE_FOLDER
        self.__threshold = THRESHOLD
        self.__shift = SHIFT
        # A single run of the manipulated on the images.
        # Displays the images (plot) of the images generated by the algorithm
        self.__debug_mode = DEBUG_MODE
        self.__image_size = IMAGE_SIZE
        # Create for each image, copy with noise
        self.__add_noise = ADD_NOISE

        self.__aleph_bet_folder_name = folders_name_dict
        self.__counter_filename_dict = {}
        self.__noise_size_per_img_line = noise_size_per_img_line
        self.__image_location_change = False
        self.__image_file_path = None

    def convert_image_to_binary_file(self):
        if not path.isdir(self.__output_image_folder):
            makedirs(self.__output_image_folder)

        images_path_list = [path.join(self.__images_folder, filename) for filename in listdir(self.__images_folder)]
        files_path_list = [path.join(self.__output_image_folder, str(filename.split('.')[-2]) + '.txt')
                           for filename in listdir(self.__images_folder)]

        for idx, image_path in enumerate(images_path_list):
            if image_path.split('.')[-1] not in ['png', 'jpg']:
                continue
            # Convert Image to array
            img = Image.open(image_path).convert("L")
            image_binary_str = ""
            for row in np.array(img):
                for pixel in row:
                    if pixel < THRESHOLD:
                        image_binary_str += "1"
                    else:
                        image_binary_str += "0"
                image_binary_str += '\n'
            with open(files_path_list[idx], "w+") as f:
                f.write(image_binary_str)
            f.close()

    @staticmethod
    def plot_image(title, img):
        plt.title(title)
        plt.imshow(img, cmap='gray', interpolation='nearest')
        plt.show()

    def __save_image_to_file(self, file_path, img, title="11"):
        with open(file_path, 'w+') as f:
            for line in img:
                if len(line) > self.__image_size:
                    line = line[:self.__image_size]
                f.write(''.join(map(str, line)) + '\n')
        f.close()
        if self.__debug_mode is True:
            self.plot_image(title, img)

    def __save_image_with_noise_to_file(self, file_path, img, title="", noise_per_line=1):
        new_image = []
        with open(file_path, 'w+') as f:
            for line in img:
                for i in range(noise_per_line):
                    random_idx = randrange(len(line) - 1)
                    if len(line) > self.__image_size:
                        line = line[:self.__image_size]
                line = list(map(int, line))
                line[random_idx] = 1 if line[random_idx] == 0 else 0
                new_image.append(line)
                f.write(''.join(map(str, line)) + '\n')
        f.close()
        if self.__debug_mode is True:
            self.plot_image(title, new_image)

    def __create_multi_manipulated_and_save(self, sum_shift_on_image, img, label_name, curr_folder, shift_mode):
        shift_mode = shift_mode.lower()
        if sum_shift_on_image == 0:
            lines_with_zero = [[0] * self.__image_size] * self.__shift
            if shift_mode == 'down':
                for i in range(SHIFT):
                    img.pop(-1)
                img = lines_with_zero + img
            if shift_mode == 'up':
                for i in range(SHIFT):
                    img.pop(0)
                img = img + lines_with_zero
            if shift_mode == 'right':
                self.__image_location_change = True
                for i in range(SHIFT):
                    for row_idx in range(len(img)):
                        img[row_idx].pop(-1)
                        img[row_idx].insert(0, 0)
            if shift_mode == 'left':
                if self.__image_location_change:
                    with open(self.__image_file_path, 'r') as f:
                        img2 = f.readlines()
                    f.close()
                    img2 = [line.strip() for line in img2]
                    img2 = [list(map(int, line)) for line in img2]
                    img = copy(img2)
                for i in range(SHIFT):
                    for row_idx in range(len(img)):
                        img[row_idx].pop(0)
                        img[row_idx].insert(-1, 0)

            self.__save_all_manipulated_on_images(label_name, curr_folder, copy(img), shift_mode)

    def __save_all_manipulated_on_images(self, label_name, curr_folder, img, shift_mode):
        shift_mode = shift_mode.lower()
        self.__counter_filename_dict[label_name] += 1
        img_file_path = path.join(curr_folder, label_name + str(self.__counter_filename_dict[label_name]) + ".txt")
        self.__save_image_to_file(img_file_path, copy(img), "Image - Move-{}".format(shift_mode))
        if self.__add_noise is True:
            self.__counter_filename_dict[label_name] += 1
            img_file_path = path.join(curr_folder, label_name +
                                      str(self.__counter_filename_dict[label_name]) + ".txt")
            self.__save_image_with_noise_to_file(img_file_path, copy(img), "Image with noise - Move-{}".format(shift_mode))
            self.__counter_filename_dict[label_name] += 1
            img_file_path = path.join(curr_folder, label_name +
                                      str(self.__counter_filename_dict[label_name]) + ".txt")
            self.__save_image_with_noise_to_file(img_file_path, copy(img), "Image with large noise - Move-{}"
                                                 .format(shift_mode))

    def __get_images_path_file(self):
        if not path.isdir(self.__source_binary_file_folder) or len(listdir(self.__source_binary_file_folder)) == 0:
            if not path.isdir(self.__source_binary_file_folder):
                print("The folder does not exist in the following path: '{}'"
                      .format(path.join(getcwd(), self.__source_binary_file_folder)))
            elif len(listdir(self.__source_binary_file_folder)) == 0:
                print("Please insert images into the folder in the following path: '{}'"
                      .format(path.join(getcwd(), self.__source_binary_file_folder)))
            exit(1)

        if not path.isdir(self.__source_binary_file_folder):
            makedirs(self.__source_binary_file_folder)
        folder_path_list = [path.join(self.__source_binary_file_folder, folder_name) for folder_name in
                            listdir(self.__source_binary_file_folder)]
        images_path_list = []
        for folder_path in folder_path_list:
            for filename in listdir(folder_path):
                images_path_list.append(path.join(folder_path, filename))

        return images_path_list

    @staticmethod
    def __remove_digits_from_filename(filename):
        for i in range(1, len(filename) + 1):
            if str(filename[-i]).isdigit():
                filename = filename[:-i]
            else:
                break
        filename = filename.encode("ascii", "ignore").decode("utf-8")
        return filename

    def manipulated_on_images(self):
        folder_name_dict = {}
        a = self.__get_images_path_file()
        for img_path in a:
            self.__image_file_path = img_path
            try:
                # Get the name of file
                label_name = path.split(img_path)[-1].split('.')[0]
                # Remove the index from label_name
                label_name = self.__remove_digits_from_filename(label_name)
                label_name = self.__aleph_bet_folder_name[label_name]
                self.__counter_filename_dict[label_name] = self.__counter_filename_dict.get(label_name, 0)
                # Creates the folder for the class of the image (ie for each letter creates its own folder)
                curr_folder = path.join(self.__binary_output_folder, label_name)
                if not path.isdir(curr_folder):
                    folder_name_dict[label_name] = 0
                    makedirs(curr_folder)

                binary_img = ""
                if path.split(img_path)[1].split('.')[1] == 'txt':
                    with open(img_path, "r") as img_file:
                            binary_img = img_file.readlines()
                            new_img = []
                            for line in binary_img:
                                if len(line) >= self.__image_size:
                                    new_img.append(line)
                            binary_img = new_img

                # Save original image
                self.__counter_filename_dict[label_name] += 1
                img_file_path = path.join(curr_folder, label_name + str(self.__counter_filename_dict[label_name]) + ".txt")

                # Deletes the '\n' char from a line and changes the value to be a list of numbers
                # (instead of a list of a string)
                binary_img = [list(map(int, line.replace('\n', ''))) for line in binary_img]
                self.__save_image_to_file(img_file_path, binary_img, "Original-Image")
                self.__counter_filename_dict[label_name] += 1
                img_file_path = path.join(curr_folder, label_name + str(self.__counter_filename_dict[label_name]) + ".txt")
                self.__save_image_with_noise_to_file(img_file_path, binary_img, "Original-Image with noise")
                self.__counter_filename_dict[label_name] += 1
                img_file_path = path.join(curr_folder, label_name + str(self.__counter_filename_dict[label_name]) + ".txt")
                self.__save_image_with_noise_to_file(img_file_path, binary_img, "Original-Image with large noise",
                                                     self.__noise_size_per_img_line)

                sum_right_shift = 0
                sum_left_shift = 0
                sum_up_shift = [sum([sum(line) for line in binary_img[:self.__shift]])][0]
                sum_down_shift = [sum([sum(line) for line in binary_img[-self.__shift:]])][0]

                for idx in range(len(binary_img)):
                    for i in range(self.__shift):
                        sum_left_shift += binary_img[idx][i]
                        sum_right_shift += binary_img[idx][-i]

                self.__image_location_change = True
                self.__create_multi_manipulated_and_save(sum_up_shift, copy(binary_img),
                                                         label_name, curr_folder, "up")
                self.__create_multi_manipulated_and_save(sum_down_shift, copy(binary_img),
                                                         label_name, curr_folder, "down")
                self.__create_multi_manipulated_and_save(sum_right_shift, copy(binary_img),
                                                         label_name, curr_folder, "right")
                self.__create_multi_manipulated_and_save(sum_left_shift, copy(binary_img),
                                                         label_name, curr_folder, "left")

                # If the image moves to the right it changes the original image.
                #  Therefore, this value indicates that the file needs to be reread
                self.__image_location_change = False
                self.__debug_mode = False
            except Exception as e:
                print("Image save error: {}".format(img_path))
                continue

        for folder_name in listdir(self.__binary_output_folder):
            try:
                folder_path = path.join(self.__binary_output_folder, folder_name)
                if len(listdir(folder_path)) == 0:
                    rmtree(folder_path)
            except:
                print("ERROR: The folder can not be deleted in the following path: ", folder_path)
                continue


def main():
    if path.isdir(OUTPUT_FOLDER):
        rmtree(OUTPUT_FOLDER)
        sleep(1)
    image_obj = ImageClass()
    image_obj.manipulated_on_images()


if __name__ == "__main__":
    main()
